# Order.where(subscription_ends_at: param_date).
#   joins(:member).
#   where.not('subscription_starts_at >= ?', param_date.to_date + 1.day))
#   where(members: {mandate_status: ['SUBMITTED', 'ACTIVE'], automatic_renewal: true})




  # def confirm_tot_flow(mvt)
  #   [mvt.type.imp.volume + mvt.type.exp.volume, mvt.type.tot.volume].max
  # end

      # NA # select each harbour from selected_harbours
      # NA # selharbours.each do |h|

  # harbour.movements.types.where(flow: flow, code: code) # total sum to calculate

  # def sum_tot_vol_by_type(code, flow)
  #   self.movements.group(:code (&?) :flow).where(code: code, flow: flow).pluck(:volume).sum
  # end



  # def self.vol_filter_by_family(params, harbours)
  #   @filtered_by_code = []
  #   if (params[:code])
  #     params[:code].each do |c|
  #       @filtered_by_code << @selected_harbours.map do |h|
  #         h.movements.select do |movement|
  #           movement.types.where(code: c)
  #       end
  #     end
  #   else
  #     @filtered_by_code = where.[code: "a"]
  #   end
  #   return filtered_by_code
  # end

  # def self.filter_by_year(params, harbours)
  #   @filtered_by_year = []
  #   if (params[:year])
  #     params[:year].each do |y|
  #       @filtered_by_year << @harbours.map do |harbour|
  #         harbour.movement.where(year: y)
  #       end
  #     end
  #   else
  #     filtered_by_year = [Movement.maximum("year")]
  #   end
  #   return filtered_by_year
  # end

  # def filter_by_flow
  #   filtered_by_flow = []
  #   if (params[:flow])
  #     filtered_by_flow = @harbours.map do |harbour|
  #       harbour.movements.select do |movement|
  #         movement.types.where(flow: params[:flow])
  #       end
  #     end
  #   else
  #     filtered_by_flow = ["tot"]
  #   end
  #   return filtered_by_flow
  # end
